# __init__.pyimport globalPluginHandlerimport globalVarsimport osimport apiimport wximport guiimport uiimport jsonimport codecsimport timeimport threadingimport refrom scriptHandler import scriptimport configimport textInfosimport keyboardHandlerfrom keyboardHandler import KeyboardInputGestureimport coreimport addonHandlerimport inputCorefrom logHandler import logimport watchdogaddonHandler.initTranslation()CONFIG_DIR = config.getUserDefaultConfigPath()CONFIG_FILE = os.path.join(CONFIG_DIR, "xPand.jsonl")class XPandData:        def __init__(self):        self.shortcuts = {}        self.enabled = True        self._lock = threading.RLock()        self.load()        def load(self):        with self._lock:            try:                if os.path.exists(CONFIG_FILE):                    with codecs.open(CONFIG_FILE, 'r', encoding='utf-8') as f:                        for line in f:                            line = line.strip()                            if line:                                try:                                    entry = json.loads(line)                                    for code, expansions in entry.items():                                        self.shortcuts[code] = expansions                                except json.JSONDecodeError:                                    continue                else:                    self.shortcuts = self.get_defaults()                    self.save()            except Exception as e:                log.error(f"Error loading shortcuts: {e}")                self.shortcuts = self.get_defaults()                self.enabled = True        def save(self):        with self._lock:            try:                with codecs.open(CONFIG_FILE, 'w', encoding='utf-8') as f:                    for code in sorted(self.shortcuts.keys()):                        entry = {code: self.shortcuts[code]}                        f.write(json.dumps(entry, ensure_ascii=False) + '\n')                return True            except Exception as e:                log.error(f"Error saving shortcuts: {e}")                return False        def get_defaults(self):        return {            "hw": [["Hello World"]]        }        def add(self, shortcut, expansion):        with self._lock:            self.shortcuts[shortcut] = [[expansion]]            return self.save()        def remove(self, shortcut):        with self._lock:            if shortcut in self.shortcuts:                del self.shortcuts[shortcut]                return self.save()            return False        def get(self, shortcut):        with self._lock:            return self.shortcuts.get(shortcut)        def get_all(self):        with self._lock:            return self.shortcuts.copy()        def toggle_enabled(self):        with self._lock:            self.enabled = not self.enabled            self.save()            return self.enabled        def is_enabled(self):        with self._lock:            return self.enabled# Global variables to track open dialogs_xpand_dialog = None_xpand_settings_dialog = Noneclass XPandDialog(wx.Dialog):        def __init__(self, parent, xpand_data):        super(XPandDialog, self).__init__(            parent,            title=_("xPand - AutoCorrect"),            style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER        )                self.xpand_data = xpand_data        self.SetSize((600, 400))        self.init_ui()        self.Centre()                # Ensure dialog stays on top        self.SetWindowStyle(self.GetWindowStyle() | wx.STAY_ON_TOP)        self.Raise()        self.SetFocus()        def init_ui(self):        main_sizer = wx.BoxSizer(wx.VERTICAL)                # Code input field        code_label = wx.StaticText(self, label=_("Code:"))        main_sizer.Add(code_label, 0, wx.ALL, 5)                self.code_ctrl = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER)        self.code_ctrl.Bind(wx.EVT_TEXT_ENTER, self.on_paste)        main_sizer.Add(self.code_ctrl, 0, wx.EXPAND | wx.ALL, 5)                # Buttons        button_sizer = wx.BoxSizer(wx.HORIZONTAL)                self.ok_button = wx.Button(self, label=_("OK"))        self.ok_button.Bind(wx.EVT_BUTTON, self.on_paste)        button_sizer.Add(self.ok_button, 0, wx.ALL, 5)                self.cancel_button = wx.Button(self, label=_("Cancel"))        self.cancel_button.Bind(wx.EVT_BUTTON, lambda evt: self.Close())        button_sizer.Add(self.cancel_button, 0, wx.ALL, 5)                main_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)                self.SetSizer(main_sizer)                # Bind ESC key        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)                self.code_ctrl.SetFocus()        def on_char_hook(self, event):        key = event.GetKeyCode()        if key == wx.WXK_ESCAPE:            self.Close()        else:            event.Skip()        def on_paste(self, event):        code = self.code_ctrl.GetValue().strip()        if not code:            return                expansion = self.xpand_data.get(code)        if expansion:            # Get the expansion text (first definition in first group)            expansion_text = expansion[0][0] if expansion and expansion[0] else ""            if expansion_text:                self.paste_text(expansion_text)                self.Close()        else:            ui.message(_("Code not found"))        def paste_text(self, text):        try:            # Hide dialog first            self.Hide()                        # Backup clipboard            try:                clipboard_backup = api.getClipData()            except OSError:                clipboard_backup = None                        # Copy text to clipboard            try:                api.copyToClip(text)                time.sleep(0.1 if clipboard_backup is None else 0.01)                api.processPendingEvents(False)            except Exception as e:                log.error(f"Error copying to clipboard: {e}")                ui.message(_("Cannot copy to clipboard"))                self.Destroy()                return                        # Paste using robust method from xBlock            focus = api.getFocusObject()                        # Use alternative pasting methods for different window types            try:                if hasattr(focus, 'windowClassName') and focus.windowClassName == "ConsoleWindowClass":                    # Windows console window - Control+V doesn't work here                    WM_COMMAND = 0x0111                    watchdog.cancellableSendMessage(focus.windowHandle, WM_COMMAND, 0xfff1, 0)                elif hasattr(focus, 'windowClassName') and "Rich" in focus.windowClassName and "Text" in focus.windowClassName:                    # Rich Text controls - use WM_PASTE message                    WM_PASTE = 0x0302                    watchdog.cancellableSendMessage(focus.windowHandle, WM_PASTE, 0, 0)                else:                    # For other windows, try multiple methods                    try:                        # First try standard Ctrl+V                        KeyboardInputGesture.fromName("control+v").send()                    except Exception:                        try:                            # Try Shift+Insert as alternative                            KeyboardInputGesture.fromName("shift+insert").send()                        except Exception:                            # Last resort: use WM_PASTE if we have a window handle                            if hasattr(focus, 'windowHandle') and focus.windowHandle:                                WM_PASTE = 0x0302                                watchdog.cancellableSendMessage(focus.windowHandle, WM_PASTE, 0, 0)                            else:                                # If all else fails, focus might be in a non-standard control                                try:                                    focus.setFocus()                                    time.sleep(0.05)                                    KeyboardInputGesture.fromName("control+v").send()                                except Exception:                                    log.error("Failed to paste text in non-standard control")                                    ui.message(_("Cannot paste text. Please try manual paste (Ctrl+V)."))                                    self.Destroy()                                    return                        except Exception as e:                log.error(f"Error pasting text: {e}")                ui.message(_("Error pasting text"))                        # Restore clipboard            if clipboard_backup is not None:                core.callLater(300, lambda: api.copyToClip(clipboard_backup))                        except Exception as e:            log.error(f"Error in paste_text: {e}")            ui.message(_("Error pasting text"))                # Destroy dialog after paste operation        self.Destroy()class XPandSettingsDialog(wx.Dialog):        def __init__(self, parent, xpand_data):        super(XPandSettingsDialog, self).__init__(            parent,            title=_("xPand Settings"),            style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER        )                self.xpand_data = xpand_data        self.SetSize((700, 500))        self.jump_word_prefix = ""        self.last_key_time = 0.0        self.init_ui()        self.Centre()                # Ensure dialog stays on top        self.SetWindowStyle(self.GetWindowStyle() | wx.STAY_ON_TOP)        self.Raise()        self.SetFocus()        def init_ui(self):        main_sizer = wx.BoxSizer(wx.VERTICAL)                # Code list        list_label = wx.StaticText(self, label=_("Code list:"))        main_sizer.Add(list_label, 0, wx.ALL, 5)                self.code_list = wx.ListCtrl(            self,            style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_HRULES | wx.LC_VRULES        )        self.code_list.InsertColumn(0, _("Code"), width=200)        self.code_list.InsertColumn(1, _("Word"), width=450)                self.all_codes = []        self.refresh_list()                main_sizer.Add(self.code_list, 1, wx.EXPAND | wx.ALL, 5)                # Code input        code_input_label = wx.StaticText(self, label=_("Code:"))        main_sizer.Add(code_input_label, 0, wx.ALL, 5)                self.code_input = wx.TextCtrl(self)        main_sizer.Add(self.code_input, 0, wx.EXPAND | wx.ALL, 5)                # Word input        word_input_label = wx.StaticText(self, label=_("Word:"))        main_sizer.Add(word_input_label, 0, wx.ALL, 5)                self.word_input = wx.TextCtrl(self, style=wx.TE_MULTILINE, size=(-1, 100))        main_sizer.Add(self.word_input, 0, wx.EXPAND | wx.ALL, 5)                # Buttons        button_sizer = wx.BoxSizer(wx.HORIZONTAL)                self.add_button = wx.Button(self, label=_("Add"))        self.add_button.Bind(wx.EVT_BUTTON, self.on_add)        button_sizer.Add(self.add_button, 0, wx.ALL, 5)                self.edit_button = wx.Button(self, label=_("Edit"))        self.edit_button.Bind(wx.EVT_BUTTON, self.on_edit)        button_sizer.Add(self.edit_button, 0, wx.ALL, 5)                self.remove_button = wx.Button(self, label=_("Remove"))        self.remove_button.Bind(wx.EVT_BUTTON, self.on_remove)        button_sizer.Add(self.remove_button, 0, wx.ALL, 5)                self.close_button = wx.Button(self, label=_("Close"))        self.close_button.Bind(wx.EVT_BUTTON, lambda evt: self.Close())        button_sizer.Add(self.close_button, 0, wx.ALL, 5)                main_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)                self.SetSizer(main_sizer)                # Bind events        self.code_list.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_selection_changed)        self.code_list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit)        self.code_list.Bind(wx.EVT_CHAR, self.on_char)        self.code_list.Bind(wx.EVT_CONTEXT_MENU, self.on_context_menu)        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)                # Create context menu        self.context_menu = wx.Menu()        self.context_menu_add = self.context_menu.Append(wx.ID_ANY, _("&Add"))        self.context_menu_edit = self.context_menu.Append(wx.ID_ANY, _("&Edit"))        self.context_menu_remove = self.context_menu.Append(wx.ID_ANY, _("&Remove"))                self.Bind(wx.EVT_MENU, self.on_add, self.context_menu_add)        self.Bind(wx.EVT_MENU, self.on_edit, self.context_menu_edit)        self.Bind(wx.EVT_MENU, self.on_remove, self.context_menu_remove)                self.update_button_states()        self.code_list.SetFocus()        def refresh_list(self, filter_text=""):        self.code_list.DeleteAllItems()        codes = self.xpand_data.get_all()                self.all_codes = [(k, v[0][0] if v and v[0] else "") for k, v in codes.items()]        self.all_codes.sort(key=lambda x: x[0].lower())                filtered = self.all_codes        if filter_text:            filter_lower = filter_text.lower()            filtered = [(k, v) for k, v in self.all_codes                        if filter_lower in k.lower()]                for idx, (code, expansion) in enumerate(filtered):            index = self.code_list.InsertItem(idx, code)            self.code_list.SetItem(index, 1, expansion)                if self.code_list.GetItemCount() > 0:            self.code_list.Select(0)            self.code_list.Focus(0)        def update_button_states(self):        has_selection = self.code_list.GetFirstSelected() >= 0        self.edit_button.Enable(has_selection)        self.remove_button.Enable(has_selection)        if hasattr(self, 'context_menu_edit'):            self.context_menu_edit.Enable(has_selection)        if hasattr(self, 'context_menu_remove'):            self.context_menu_remove.Enable(has_selection)        def on_selection_changed(self, event):        self.update_button_states()        event.Skip()        def on_char(self, event):        # Handle incremental search like Siam Center        key_code = event.GetKeyCode()        unicode_key = event.GetUnicodeKey()                if unicode_key != wx.WXK_NONE:            current_time = time.time()            char = chr(unicode_key)                        # Reset prefix if too much time has passed            if current_time - self.last_key_time > 1.0:                self.jump_word_prefix = ""                        self.jump_word_prefix += char            self.last_key_time = current_time                        # Find the first code starting with the prefix            found = False            for i in range(self.code_list.GetItemCount()):                code = self.code_list.GetItemText(i, 0)                if code.startswith(self.jump_word_prefix):                    self.code_list.Select(i)                    self.code_list.Focus(i)                    self.code_list.EnsureVisible(i)                    ui.message(_("{}").format(code))                    found = True                    break                        if not found:                # If no exact match, try partial match                for i in range(self.code_list.GetItemCount()):                    code = self.code_list.GetItemText(i, 0)                    if self.jump_word_prefix in code:                        self.code_list.Select(i)                        self.code_list.Focus(i)                        self.code_list.EnsureVisible(i)                        ui.message(_("{}").format(code))                        found = True                        break                        if not found:                self.jump_word_prefix = self.jump_word_prefix[:-1]                if self.jump_word_prefix:                    ui.message(_("No code starting with: {}").format(self.jump_word_prefix))                else:                    ui.message(_("No matching code"))        else:            event.Skip()        def on_context_menu(self, event):        self.PopupMenu(self.context_menu)        def on_char_hook(self, event):        key = event.GetKeyCode()        if key == wx.WXK_ESCAPE:            self.Close()        else:            event.Skip()        def on_add(self, event):        code = self.code_input.GetValue().strip()        word = self.word_input.GetValue().strip()                if not code:            wx.MessageBox(_("Please enter a code"), _("Error"), wx.OK | wx.ICON_ERROR)            return                if not word:            wx.MessageBox(_("Please enter a word"), _("Error"), wx.OK | wx.ICON_ERROR)            return                if self.xpand_data.get(code):            wx.MessageBox(_("Code already exists"), _("Error"), wx.OK | wx.ICON_ERROR)            return                if self.xpand_data.add(code, word):            self.refresh_list()            self.code_input.SetValue("")            self.word_input.SetValue("")            ui.message(_("Add Succeeded"))        else:            wx.MessageBox(_("Error adding code"), _("Error"), wx.OK | wx.ICON_ERROR)        def on_edit(self, event):        selection = self.code_list.GetFirstSelected()        if selection >= 0:            code = self.code_list.GetItemText(selection, 0)            expansion = self.code_list.GetItemText(selection, 1)                        self.code_input.SetValue(code)            self.word_input.SetValue(expansion)                        # Remove old code and prepare for edit            self.xpand_data.remove(code)            self.refresh_list()                        ui.message(_("Edit mode. Modify code and word, then click Edit to save."))        def on_remove(self, event):        selection = self.code_list.GetFirstSelected()        if selection >= 0:            code = self.code_list.GetItemText(selection, 0)                        confirm = wx.MessageBox(                _("Are you sure you want to delete the code '{name}'?").format(name=code),                _("Confirm deletion"),                wx.YES_NO | wx.ICON_QUESTION            )                        if confirm == wx.YES:                if self.xpand_data.remove(code):                    self.refresh_list()                    self.code_input.SetValue("")                    self.word_input.SetValue("")                    ui.message(_("Code removed"))                else:                    wx.MessageBox(_("Error removing code"), _("Error"), wx.OK | wx.ICON_ERROR)class GlobalPlugin(globalPluginHandler.GlobalPlugin):        def __init__(self):        super(GlobalPlugin, self).__init__()        self.xpand_data = XPandData()        self.last_gesture_time = 0        self.gesture_count = 0        log.info("xPand AutoCorrect loaded")        @script(        description=_("Open xPand AutoCorrect"),        category="xPand",        gesture="kb:control+f3"    )    def script_openXPand(self, gesture):        current_time = time.time()                # Count gestures for double tap detection        self.gesture_count += 1                # Schedule gesture processing with delay to detect double tap        core.callLater(300, self.process_gesture, current_time)        def process_gesture(self, gesture_time):        if self.gesture_count == 1:            # Single tap - open main dialog if in text editor            if self.is_text_editor():                self.open_xpand_dialog()            # If not in text editor, do nothing (return control to normal context)        elif self.gesture_count >= 2:            # Double tap - open settings            self.open_xpand_settings()                # Reset gesture count        self.gesture_count = 0        def open_xpand_dialog(self):        global _xpand_dialog                def show_dialog():            global _xpand_dialog                        try:                if not wx.IsMainThread():                    wx.CallAfter(show_dialog)                    return                                # Close existing dialog if open                if _xpand_dialog:                    try:                        _xpand_dialog.Close()                        _xpand_dialog.Destroy()                    except:                        pass                    _xpand_dialog = None                                # Create new dialog                _xpand_dialog = XPandDialog(gui.mainFrame, self.xpand_data)                _xpand_dialog.Bind(wx.EVT_CLOSE, self.on_xpand_dialog_close)                gui.runScriptModalDialog(_xpand_dialog)                            except Exception as e:                log.error(f"Error opening xPand dialog: {e}")                ui.message(_("Error opening xPand"))                wx.CallAfter(show_dialog)        def open_xpand_settings(self):        global _xpand_settings_dialog                def show_dialog():            global _xpand_settings_dialog                        try:                if not wx.IsMainThread():                    wx.CallAfter(show_dialog)                    return                                # Close existing dialog if open                if _xpand_settings_dialog:                    try:                        _xpand_settings_dialog.Close()                        _xpand_settings_dialog.Destroy()                    except:                        pass                    _xpand_settings_dialog = None                                # Create new dialog                _xpand_settings_dialog = XPandSettingsDialog(gui.mainFrame, self.xpand_data)                _xpand_settings_dialog.Bind(wx.EVT_CLOSE, self.on_xpand_settings_close)                gui.runScriptModalDialog(_xpand_settings_dialog)                            except Exception as e:                log.error(f"Error opening xPand settings: {e}")                ui.message(_("Error opening xPand settings"))                wx.CallAfter(show_dialog)        def on_xpand_dialog_close(self, event):        global _xpand_dialog        _xpand_dialog = None        event.Skip()        def on_xpand_settings_close(self, event):        global _xpand_settings_dialog        _xpand_settings_dialog = None        event.Skip()        @script(        description=_("Open xPand Settings"),        category="xPand"    )    def script_openSettings(self, gesture):        self.open_xpand_settings()        def is_text_editor(self):        """Check if focused application is a text editor"""        try:            focus = api.getFocusObject()            if not focus:                return False                        # Check window class names for common text editors            window_class = getattr(focus, 'windowClassName', '').lower()                        # Common text editor window classes            text_editor_classes = [                'edit',  # Standard Windows edit control                'richedit',  # Rich edit control                'richedit20a', 'richedit20w',  # Rich edit versions                'richedit50w',  # Office rich edit                'scintilla',  # Scintilla-based editors (Notepad++, etc.)                'notepad',  # Notepad                'wordpad',  # WordPad                'w_word',  # Microsoft Word                'opusapp',  # WordPerfect                'w_frame',  # WordPerfect                'thunderrt6formdc',  # Visual Basic forms                'tworddocument',  # TextMaker            ]                        # Check if window class contains any text editor identifier            for editor_class in text_editor_classes:                if editor_class in window_class:                    return True                        # Additional check for process names            try:                process_name = getattr(focus, 'processName', '').lower()                text_editor_processes = [                    'notepad.exe',                    'wordpad.exe',                    'winword.exe',                    'writer.exe',  # LibreOffice Writer                    'soffice.exe',  # LibreOffice                    'code.exe',  # VS Code                    'notepad++.exe',                    'wordview.exe',  # Word Viewer                ]                                for editor_process in text_editor_processes:                    if editor_process in process_name:                        return True            except:                pass                        return False                    except Exception as e:            log.error(f"Error checking text editor: {e}")            return False    def terminate(self):        global _xpand_dialog, _xpand_settings_dialog                # Close any open dialogs        if _xpand_dialog:            try:                _xpand_dialog.Close()                _xpand_dialog.Destroy()            except:                pass            _xpand_dialog = None                if _xpand_settings_dialog:            try:                _xpand_settings_dialog.Close()                _xpand_settings_dialog.Destroy()            except:                pass            _xpand_settings_dialog = None                    log.info("xPand AutoCorrect terminated")        super(GlobalPlugin, self).terminate()